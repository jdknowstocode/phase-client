var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/plugin/index.ts
var plugin_exports = {};
__export(plugin_exports, {
  default: () => plugin_default
});
module.exports = __toCommonJS(plugin_exports);

// src/plugin/server/index.ts
var http = __toESM(require("http"), 1);
var import_path2 = require("path");
var import_koa = __toESM(require("koa"), 1);
var import_koa_bodyparser = __toESM(require("koa-bodyparser"), 1);
var import_cors = __toESM(require("@koa/cors"), 1);
var import_get_port = __toESM(require("get-port"), 1);

// src/plugin/server/requests/get.ts
var fs = __toESM(require("fs/promises"), 1);
var import_koa_router = __toESM(require("koa-router"), 1);

// src/common/isNodeError.ts
function isNodeError(error) {
  return "code" in error;
}
var isNodeError_default = isNodeError;

// src/plugin/server/requests/get.ts
function createRoutes(resolvePath) {
  async function readFile2(path) {
    const data = await fs.readFile(path);
    return data;
  }
  async function readdir2(path, withFileTypes) {
    if (!withFileTypes) {
      const items2 = await fs.readdir(path);
      return items2;
    }
    const dirents = await fs.readdir(path, { withFileTypes: true });
    const items = [];
    dirents.forEach((dirent) => {
      const simpleDirent = {
        name: dirent.name,
        dir: dirent.isDirectory()
      };
      if (dirent.isFile() || dirent.isDirectory()) {
        items.push(simpleDirent);
      }
    });
    return items;
  }
  async function stat2(path) {
    const stats = await fs.stat(path);
    if (stats.isFile() || stats.isDirectory()) {
      const simpleStats = __spreadProps(__spreadValues({}, stats), {
        dir: stats.isDirectory()
      });
      return simpleStats;
    }
    throw new Error();
  }
  const router = new import_koa_router.default();
  router.get(/.*/, async (ctx) => {
    ctx.status = 500;
    ctx.body = "Relay server error";
    let path;
    try {
      path = resolvePath(ctx.path);
    } catch (err) {
      if (isNodeError_default(err)) {
        ctx.status = 403;
        ctx.body = err.message;
      }
      return;
    }
    if (ctx.query.cmd) {
      if (ctx.query.cmd === "readFile") {
        try {
          const response = await readFile2(path);
          ctx.status = 200;
          ctx.body = response;
          return;
        } catch (err) {
          if (isNodeError_default(err)) {
            if (err.code === "ENOENT") {
              ctx.status = 404;
              ctx.body = err.message;
              return;
            }
            ctx.status = 400;
            ctx.body = err.message;
          }
          return;
        }
      }
      if (ctx.query.cmd === "readdir") {
        if (ctx.query.withFileTypes) {
          try {
            const response = await readdir2(path, true);
            ctx.status = 200;
            ctx.body = response;
            return;
          } catch (err) {
            if (isNodeError_default(err)) {
              if (err.code === "ENOENT") {
                ctx.status = 404;
                return;
              }
              ctx.status = 400;
              ctx.body = err.message;
            }
            return;
          }
        } else {
          try {
            const response = await readdir2(path);
            ctx.status = 200;
            ctx.body = response;
            return;
          } catch (err) {
            if (isNodeError_default(err)) {
              if (err.code === "ENOENT") {
                ctx.status = 404;
                return;
              }
              ctx.status = 400;
              ctx.body = err.message;
            }
            return;
          }
        }
      }
      if (ctx.query.cmd === "stat") {
        try {
          const response = await stat2(path);
          ctx.status = 200;
          ctx.body = response;
          return;
        } catch (err) {
          if (isNodeError_default(err)) {
            if (err.code === "ENOENT") {
              ctx.status = 404;
              return;
            }
            ctx.status = 400;
            ctx.body = err.message;
          }
        }
      }
    } else {
      ctx.status = 400;
      ctx.body = "Command query param not specified";
    }
  });
  return router.routes();
}

// src/plugin/server/requests/post.ts
var fs2 = __toESM(require("fs/promises"), 1);
var import_path = require("path");
var import_koa_router2 = __toESM(require("koa-router"), 1);
function createRoutes2(resolvePath) {
  const router = new import_koa_router2.default();
  router.post(/.*/, async (ctx) => {
    ctx.status = 500;
    ctx.body = "Relay server error";
    let path;
    try {
      path = resolvePath(ctx.path);
    } catch (err) {
      if (isNodeError_default(err)) {
        ctx.status = 403;
        ctx.body = err.message;
      }
      return;
    }
    if (ctx.query.cmd) {
      if (ctx.query.cmd === "writeFile") {
        const dir = (0, import_path.dirname)(path);
        const bdy = ctx.request.body;
        const { data } = bdy;
        try {
          try {
            await fs2.mkdir(dir, { recursive: true });
          } catch (err) {
          }
          await fs2.writeFile(path, data);
          ctx.status = 200;
        } catch (err) {
          ctx.status = 500;
        }
      }
    } else {
      ctx.status = 400;
      ctx.body = "Command query param not specified";
    }
  });
  return router.routes();
}

// src/plugin/server/requests/delete.ts
var fs3 = __toESM(require("fs/promises"), 1);
var import_koa_router3 = __toESM(require("koa-router"), 1);
function createRoutes3(resolvePath) {
  const router = new import_koa_router3.default();
  router.delete(/.*/, async (ctx) => {
    ctx.status = 500;
    ctx.body = "Relay server error";
    let path;
    try {
      path = resolvePath(ctx.path);
    } catch (err) {
      if (isNodeError_default(err)) {
        ctx.status = 403;
        ctx.body = err.message;
      }
      return;
    }
    if (ctx.query.cmd) {
      if (ctx.query.cmd === "rm") {
        let recursive = false;
        let force = false;
        if (ctx.query.recursive)
          recursive = true;
        if (ctx.query.force)
          force = true;
        try {
          await fs3.rm(path, { recursive, force });
          ctx.status = 200;
        } catch (err) {
          if (isNodeError_default(err)) {
            if (err.code === "ENOENT") {
              ctx.status = 404;
            } else if (err.code === "ERR_FS_EISDIR") {
              ctx.status = 400;
            } else {
              ctx.status = 500;
            }
            ctx.body = err.message;
          }
        }
      }
    } else {
      ctx.status = 400;
      ctx.body = "Command query param not specified";
    }
  });
  return router.routes();
}

// src/plugin/server/index.ts
var FsServer = class {
  server;
  rootDir;
  activePort;
  options;
  constructor(options) {
    this.options = options;
    this.rootDir = (0, import_path2.resolve)(this.options.rootDir);
    const app = new import_koa.default();
    app.use((0, import_koa_bodyparser.default)());
    app.use((0, import_cors.default)());
    app.use(createRoutes(this.resolvePath));
    app.use(createRoutes2(this.resolvePath));
    app.use(createRoutes3(this.resolvePath));
    this.server = http.createServer(app.callback());
  }
  async start(silent) {
    const port = await (0, import_get_port.default)({ port: this.options.port });
    this.server.listen(port, () => {
      if (!silent) {
        console.log("\x1B[41m");
        console.log(`fs relay server is running on port ${port}`);
        console.log("Please be careful since any requests to this server can modify your actual file system");
        console.log(`\x1B[43m\x1B[30mThe relay server sees ${this.rootDir} as root. Everything outside this directory is safe`);
        console.log("\x1B[0m");
      }
    });
    this.activePort = port;
  }
  stop() {
    this.server.close();
  }
  resolvePath = (path) => {
    let cleanPath = path;
    while (cleanPath.length > 0 && cleanPath.startsWith("/")) {
      cleanPath = cleanPath.substring(1);
    }
    const p = (0, import_path2.resolve)(this.rootDir, cleanPath);
    if (!p.startsWith(this.rootDir)) {
      throw new Error("ABOVEROOT");
    } else {
      return p;
    }
  };
};
var server_default = FsServer;

// src/plugin/Options.ts
var defaultOptions = {
  port: 7070,
  rootDir: ""
};
function resolveOptions(userOptiuons) {
  return Object.assign(defaultOptions, userOptiuons);
}

// src/plugin/index.ts
function VitePluginFs(userOptiuons = {}) {
  const options = resolveOptions(userOptiuons);
  const virtualModuleId = "virtual:fs";
  const resolvedVirtualModuleId = `\0${virtualModuleId}`;
  let server = null;
  let isProd = true;
  return {
    name: "vite-plugin-fs",
    apply: "serve",
    config(_, env) {
      if (env.mode === "development") {
        isProd = false;
      }
      return {
        build: {
          rollupOptions: {
            external: "virtual:fs"
          }
        },
        optimizeDeps: {
          exclude: [virtualModuleId]
        }
      };
    },
    async buildStart() {
      if (!isProd) {
        server = new server_default(options);
        await server.start();
      }
    },
    resolveId(id) {
      if (id === virtualModuleId) {
        return resolvedVirtualModuleId;
      }
      return null;
    },
    load(id) {
      if (typeof (server == null ? void 0 : server.activePort) === "number") {
        if (id === resolvedVirtualModuleId) {
          return `export const activePort = ${server.activePort}`;
        }
      }
      return null;
    },
    closeBundle() {
      server == null ? void 0 : server.stop();
    }
  };
}
var plugin_default = VitePluginFs;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
